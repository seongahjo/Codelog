+++
categories = ["데이터베이스"]
date = "2018-10-01T05:27:28+00:00"
description = ""
draft = true
tags = ["데이터베이스", "DB", "트랜잭션"]
title = "트랜잭션"

+++
## 트랜잭션

> 데이터베이스의 상태를 변화시키기 위해 수행하는 **작업의 단위**

### 트랜잭션이 보장해야하는 ACID

***

#### 원자성 (Atomicity)

한 트랜잭션 내에서 실행한 모든 작업들은 하나의 작업으로 간주한다. 트랜잭션 내의 작업들은 모두 성공 또는 모두 실패되어야 한다. (All or Nothing)

#### 일관성 (Consistency)

모른 트랜잭션은 일관성 있는 데이터베이스 상태를 유지한다.

일관성 있는 상태는 트랜잭션 전이나 후에 데이터베이스에 정의된 규칙, 제약(Constraints)들이 지켜져야 한다.

#### 격리성 (Isolation)

동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리 해야한다.

##### 격리성 관련 문제점

***

##### Dirty Read

> 한 트랜잭션(T1)이 데이터에 접근하여 값을 'A'에서 'B'로 변경했고 아직 **커밋을 하지 않았았다면** 다른 트랜잭션(T2)가 해당 데이터를 Read했을 때 T2가 읽은 데이터는 B가 될 것이다. 하지만 T1이 커밋을 하지 않고 종료한다면 T2가 가진 데이터는 꼬이게 된다.

T1 데이터 변경-> T2 데이터 Read -> T1 롤백

##### Non-Repeatable Read

> 한 트랜잭션(T1)이 데이터를 Read하고 있다. 이때 다른 트랜잭션(T2)가 데이터에 접근하여 값을 변경 또는 삭제하고 커밋을 한다. 그 후 T1이 **다시 해당 데이터를 Read하고자 하면** 변경된 데이터 혹은 사라진 데이터를 찾게 된다.

T1 데이터 Read -> T2 데이터 변경 & 커밋 -> T1 데이터 Read

##### Phantom Read

> 트랜잭션(T1) 중에 특정 조건으로 데이터를 검색하여 다수의 결과를 얻었다. 이때 다른 트랜잭션(T2)가 접근해 해당 조건의 데이터 일부를 삭제 또는 추가 하고 커밋을 한다. 아직 끝나지 않은 T1이 다시 한 번 해당 조건으로 데이터를 조회하면 T2에서 추가/삭제된 데이터가 함께 조회/누락된다.

T1 데이터 Read -> T2 데이터 변경 & 커밋 -> T1 데이터 Read

##### Dirty Read vs Non-Repeated Read & Phantom Read

Dirty Read는 Uncommitted data에 대해서 발생하는 문제지만 Non-Repeatable Read와 Phantom Read는 committed data에 대해서 발생하는 문제다.

##### Non-Repeatable Read vs Phantom Read

Non-Repeatable Read는 Single Row를 읽을 때 발생하는 문제고 Phantom Read는 Multiple Row를 읽을 때 발생하는 문제다.

##### 격리수준

***

내려갈수록 격리수준이 높아지지만 동시 처리 성능은 떨어진다.

##### Read Uncommitted

한 트랜잭션에서 커밋하지 않은 데이터에 다른 트랜잭션이 접근 가능하다. 즉, 커밋하지 않은 데이터를 읽을 수 있다.

> 이 수준은 위에서 언급한 모든 문제의 발생 가능성이 존재한다. 하지만 동시 처리 성능은 가장 높다.

**발생 문제점**

* Dirty Read
* Non-Repeatable Read
* Phantom Read

##### Read Committed

커밋이 완료된 데이터만 읽을 수 있다.

> Dirty Read가 발생할 여지는 없으나 Read Uncommitted 수준 보다 동시 처리 성능은 떨어진다. 대신 Non-Repeatable Read 및 Phantom Read는 발생 가능하다. 데이터베이스들은 보통 Read Committed를 디폴트 수준으로 지정한다.

**발생 문제점**

* Non-Repeatable Read
* Phantom Read

##### Repeatable Read

트랜잭션 내에서 한 번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다.

> 이는 개별 데이터 이슈인 Dirty Read나 Non-Repeatable Read는 발생하지 않지만 결과 집합 자체가 달라지는 Phantom Read는 발생 가능하다.

**발생 문제점**

* Phantom Read

##### Serializable

가장 엄격한 격리 수준. 위 3가지 문제점을 모두 커버 가능하다. 하지만 동시 처리 성능은 급격히 떨어질 수 있다.

#### 지속성 (Durability)

트랜잭션을 성공적으로 마치면 그 결과는 항상 저장되어야 한다.

### 트랜잭션의 잠김(Lock)

***

트랜잭션이 발생하면 락 (Lock)이 걸리는데 SELECT시에는 **공유 락**, CREATE/INSERT/DELETE시에는 **배타적 락**이 걸린다.

#### 공유락

* SELECT 문이 수행 종료되면 잠금 해제된다.
* 공유 락은 배타적 락을 허용하지 않는다.
* 공유 락끼리는 접근 할 수 있다.

공유 락이 걸린 동안 데이터를 변경할 수 없다.

#### 배타적 락

* 트랜잭션이 끝나야 락이 잠금 해제된다.

Update Lock

Intent Lock

공유 락 혹은 배타적 락이 걸렸다는 걸 알려주는 락. 두 락과 같이 걸린다. 

업데이트할 때 배타적 락을 걸기전에 거는 락

### 데이터베이스 회복

***

데이터베이스는 디스크에 데이터를 저장하며 전체 데이터베이스의 일부분을 메인 메모리에 유지한다. DBMS는 데이터를 고정 길이의 페이지(page)로 저장하며 디스크에 읽거나 쓸 때에 페이지 단위로 입출력이 이루어진다. 메인 메모리에 유지되는 부분을 페이지 버퍼 관리자 또는 버퍼 관리자라고 한다.

트랜잭션이 비정상적으로 종료됐을 떄 마지막으로 저장된 체크포인트를 기준으로 커밋이 안됐으나 실행된 작업을 되돌리거나 (Undo) 커밋이 됐으나 반영이 안된 작업을 실행한다. (Redo) Undo와 Redo를 위해서 log를 활용하는 구조를 사용한다. 앞서 언급했던 버퍼 관리자의 버퍼 관리 정책에 따라 Redo와 Undo가 필요할수도 필요하지 않을 수도 있다.

#### Undo

버퍼에 저장된 페이지를 디스크에 쓰는 시점을 정하는 STEAL정책과 ¬STEAL정책이 있다.

##### STEAL정책

> 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책

STEAL정책을 채택할경우 Undo 작업이 필요하다.

##### ¬STEAL정책

> 수정된 페이지를 최소한 트랜잭션 종료시점까지 버퍼에 유지하는 정책

¬STEAL정책을 채택할경우 메모리 버퍼에 있는 작업들을 디스크에 반영하지 않으면 되므로 Undo 작업이 간단해진다. 하지만 매우 큰 메모리 버퍼가 필요하다.

#### Redo

마찬가지로 버퍼에 저장된 페이지를 디스크에 쓰는 시점을 정하는 FORCE정책과 ¬FORCE정책이 있다.

##### FORCE

> 수정했던 모든 페이지를 트랜잭션 커밋 시점에 디스크에 반영하는 정책

FORCE 정책을 따를경우 트랜잭션이 커밋되면 수정되었던 페이지들이 이미 디스크상의 데이터베이스에 반영되었으므로 REDO 복구가 필요없다.

FORCE정책을 따르더라도 데이터베이스 백업으로부터의 복구 (미디어 복구) 시에는 REDO 복구가 요구된다.

##### ¬FORCE

> 수정했던 페이지를 트랜잭션 커밋 시점에 디스크에 반영하지 않는 정책

¬FORCE 정책을 따르면 커밋한 트랜잭션 내용이 디스크 상의 데이터베이스 상에 반영되어있지 않을 수 있기 때문에 REDO 복구가 필요하다.

일반적인 DBMS는 버퍼관리 정책으로 STEAL과 ¬FORCE 정책을 채택하고 있다.

***

로그는 데이터베이스의 모든 갱신 작업을 기록한다. 로그 데이터는 기록할 오브젝트에 따라 물리적 / 논리적 로깅으로 분류할 수 있으며 데이터베이스의 상태 또는 변화를 기록하냐에 따라서 분류할 수 있다.

* 물리적인 상태 로깅
* 물리적인 전이 로깅
* 논리적인 전이 로깅

  상태 로깅은 데이터베이스의 내용을 복사한다고 생각하면 되고 전이 로깅은 변화를 기록하는 것이다. 물리적인 전이 로깅은 XOR 연산 한 후의 결과 값을 로깅하며 논리적인 전이 로깅은 어떤 일을 했나를 로깅한다.

DBMS는 이 세가지 방법을 혼합하여 사용한다. 로그 레코드는 **UNDO 로그**, **REDO 로그**, **커밋 로그** 등 다양한 로그 레코드가 존재한다.

##### 용어

* 트랜잭션
* 락
* 격리수준
* 격리성 문제
* ACID
* Redo
* Undo
* log

##### 참조

[DBMS는 어떻게 트랜잭션을 관리할까?](https://d2.naver.com/helloworld/407507)