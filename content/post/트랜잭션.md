+++
categories = ["데이터베이스"]
date = "2018-10-01T05:27:28+00:00"
description = ""
draft = true
tags = ["데이터베이스", "DB", "트랜잭션"]
title = "트랜잭션"

+++
## 트랜잭션

> 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위

### 트랜잭션이 보장해야하는 ACID

***

#### 원자성 (Atomicity)

한 트랜잭션 내에서 실행한 작업들은 하나의 작업으로 간주한다. 모두 성공 또는 모두 실패되어야 한다. (All or Nothing)

#### 일관성 (Consistency)

모른 트랜잭션은 일관성 있는 데이터베이스 상태를 유지한다.

트랜잭션 전이나 후에 데이터베이스에 정의된 규칙, 제약(Constraints)들이 지켜져야 한다.

#### 격리성 (Isolation)

동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리 해야한다.

##### 격리성 관련 문제점

***

###### Dirty Read

한 트랜잭션(T1)이 데이터에 접근하여 값을 'A'에서 'B'로 변경했고 아직 커밋을 하지 않았을 때 다른 트랜잭션(T2)가 해당 데이터를 Read하면 T2가 읽은 데이터는 B가 될 것이다. 하지만 T1이 커밋을 하지 않고 종료한다면 T2가 가진 데이터는 꼬이게 된다.

###### Non-Repeatable Read

한 트랜잭션(T1)이 데이터를 Read하고 있다. 이때 다른 트랜잭션(T2)가 데이터에 접근하여 값을 변경 또는 삭제하고 커밋을 한다. 그 후 T1이 다시 해당 데이터를 Read하고자 하면 변경된 데이터 혹은 사라진 데이터를 찾게 된다.

###### Phantom Read

트랜잭션(T1) 중에 특정 조건으로 데이터를 검색하여 다수의 결과를 얻었다. 이때 다른 트랜잭션(T2)가 접근해 해당 조건의 데이터 일부를 삭제 또는 추가 했을 때 아직 끝나지 않은 T1이 다시 한 번 해당 조건으로 데이터를 조회하면 T2에서 추가/삭제된 데이터가 함께 조회/누락된다. 이때 T2가 롤백하면 데이터가 꼬인다.

##### 격리수준

***

내려갈수록 격리수준이 높아지지만 동시 처리 성능은 떨어진다.

트랜잭션이 발생하면 락 (Lock)이 걸리는데 SELECT시에는 공유 락, CREATE/INSERT/DELETE시에는 배타적 락이 걸린다.

###### Read Uncommitted

한 트랜잭션에서 커밋하지 않은 데이터에 다른 트랜잭션이 접근 가능하다. 즉, 커밋하지 않은 데이터를 읽을 수 있다.

> 이 수준은 위에서 언급한 모든 문제의 발생 가능성이 존재한다. 하지만 동시 처리 성능은 가장 높다.

**발생 문제점**

* Dirty Read
* Non-Repeatable Read
* Phantom Read

###### Read Committed

커밋이 완료된 데이터만 읽을 수 있다.

> Dirty Read가 발생할 여지는 없으나 Read Uncommitted 수준 보다 동시 처리 성능은 떨어진다. 대신 Non-Repeatable Read 및 Phantom Read는 발생 가능하다. 데이터베이스들은 보통 Read Committed를 디폴트 수준으로 지정한다.

**발생 문제점**

* Non-Repeatable Read
* Phantom Read

###### Repeatable Read

트랜잭션 내에서 한 번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다.

> 이는 개별 데이터 이슈인 Dirty Read나 Non-Repeatable Read는 발생하지 않지만 결과 집합 자체가 달라지는 Phantom Read는 발생 가능하다.

**발생 문제점**

* Phantom Read

###### Serializable

가장 엄격한 격리 수준. 위 3가지 문제점을 모두 커버 가능하다. 하지만 동시 처리 성능은 급격히 떨어질 수 있다.

#### 지속성 (Durability)

트랜잭션을 성공적으로 마치면 그 결과는 항상 저장되어야 한다.